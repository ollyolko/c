// бінарні (двійкові) файли

//режими відкриття
/*
rb - відкрити файл тільки для читання
wb - відкрити файл тільки для запису
ab - відкрити файл для запису в кінець (дозапис)
rb+  - відкрити файл для читання і запису (лише для існуючих файлів!)
wb+  - відкрити файл для запису і читання
ab+  - відкрити файл для запису в кінець (дозапис) і читання
*/

// функції навігації по файлу
//fseek(FILE *stream, long int offset, int origin); // пересуває покажчик поточної позиції у потоці stream на offset байт вперед (якщо -offset - то назад), стартуючи з позиції origin (SEEK_SET(0) - початок файлу, SEEK_CUR(1) - поточний байт, SEEK_END(2) - кінець файлу)
//long int ftell(FILE *stream); // повертає номер байта поточної позиції у файловому потоці stream
//rewind(FILE *stream); // встановлює покажчик поточної позиції у потоці stream на ПОЧАТОК

/*#include <stdio.h>

main()
{

    int a;
    FILE* f=fopen("file_name","rb"); // файл відкрито в режимі читання
    ... // перевірка на успішність відкриття
    fseek(f, (long)sizeof(a), SEEK_SET);// переміщення вперед від початку файлу на довжину (кількість байт) змінної а
    fseek(f, -(long)sizeof(a), SEEK_CUR);// переміщення назад від поточної позиції на довжину змінної а
}
*/
/* task 1.
1) виберіть в якості “піддослідного” файл одного з двійкових типів;
2) складіть програму, що виконує наступні дії:
    через файлову змінну встановлює зв’язок з вибраним файлом (в будь-якому режимі);
    оголошує змінну a одного з чисельних типів;
    встановлює покажчик поточної позиції у файловому потоці на початок,
    виводить його значення на екран;
    переміщує покажчик вперед на довжину змінної a (початок відліку - SEEK_CUR),
    виводить на екран поточну позицію;
    переміщує покажчик вперед на довжину змінної a (початок відліку - SEEK_SET),
    виводить на екран поточну позицію (результат порівняйте з попереднім,
    зробіть висновки);
    переміщує покажчик назад на довжину змінної a (початок відліку - SEEK_CUR),
    виводить на екран поточну позицію (результат порівняйте з отриманими раніше, зробіть висновки).
*/

// функції читання і запису даних до бінарних файлів
//int fread(mp, el_size, el_number, fp); // здійснює копіювання (читання) блоку даних
//(кількість el_number помножити на розмір el_size байт одного елемента - число, символ, структура тощо)
//від поточної позиції покажчика на файл fp за адресою, на яку вказує покажчик mp. Повертає кількість
//успішно прочитаних елементів

/*Параметри функції:
 mp – покажчик адреси в пам’яті, за якою записуються дані;
 el_size – розмір елемента даних в байтах (в залежності від типу);
 el_number – кількість елементів, які потрібно прочитати;
 fp – дескриптор відкритого файлу, з якого читаються дані.
*/

/*int fwrite(mp, el_size, el_number, fp); // здійснює копіювання (запис) блоку даних
 * (кількість el_number помножити на розмір el_size байт одного елемента - число, символ, структура тощо),
 *  розміщених в пам'яті за адресою, на яку вказує покажчик mp, в поточну позицію покажчика на файл fp.
 * Повертає кількість успішно записаних елементів

#include <stdio.h>
#define N 10 // фіксуємо потрібну кількість елементів масиву

main()
{
    int i, n, A[N];
    FILE* fp; // дескриптор файлу

    fp = fopen( "input.dat", "rb" ); // відкрити двійковий файл на читання
    n = fread ( A, sizeof(int), N, fp ); // читаємо в масив потрібну кількість чисел
    if ( n < N ) { // якщо чисел у файлі менше - помилка!
        printf("Reading error");
        return;
    }
    fclose ( fp ); // закрити файл
    for ( i = 0; i < N; i ++ )
        A[i] = A[i] * 2; // модифікуємо прочитаний масив
    fp = fopen( "output.dat", "wb" ); // відкрити двійковий файл на запис
    fwrite ( A, sizeof(int), N, fp ); // записати масив у файл
    fclose ( fp ); // закрити файл
}
*/
/* task 2.
1) оголошуються два масиви цілих чисел різної розмірності(наприклад, A[N] і B[M]);
2) дані з двійкового файлу спочатку читаються в масив A[N] ; масив B[M] попередньо
 заповнюється нулями;
3) якщо даних у файлі більше, ніж розмірність N - залишок даних записується
в масив B[M] ;
4) якщо даних у файлі більше, ніж сукупна розмірність обох масивів - видається
повідомлення про помилку і вихід з програми;
5) у інший файл записати послідовно числа - суми відповідних елементів масивів A[N]
і B[M] ;
6) вивести на екран вміст обох масивів, а також дані з “вихідного” файлу,
перевірити результати на коректність.
*/

/*
#include <stdio.h>
#define N 10
#define M 15

int main(){
    int A[N], B[M]={0}, sum[N], i, a=0, k;
    FILE *in, *out;

    in=fopen("binput.dat", "rb");
    if(!in){
        printf("error");
    }

    fread(A, sizeof(int), N, in);
    fread(B, sizeof(int), M, in);
    fseek(in,1,SEEK_CUR);

    if((fread(&a, sizeof(int), 1, in))!=0){
        printf("many data in file");
        return 1;
    }


    for(i=0;i<N;i++){
        printf("A[%d]=%d\n",i,A[i]);
    }
    for(i=0;i<M;i++){
        printf("B[%d]=%d\n",i,B[i]);
    }

    fclose(in);

    for(i=0; i<N;i++){
        sum[i]=A[i]+B[i];
    }

    out=fopen("bout.dat", "wb");
    fwrite(sum,sizeof(int),N,out);
    fclose(out);

    in=fopen("bout.dat", "rb");
    fread(sum, sizeof(int), N, in);
    fclose(in);

    for(i=0;i<N;i++){
        printf("%d ",sum[i]);
    }

    printf("\nenter k:");
    scanf("%d", &k);
    if(k>=N){
        printf("error. out of file.");
        return 1;
    }

    in=fopen("bout.dat", "rb");
    fseek(in,sizeof(int)*k,SEEK_SET);


    fread(&a, sizeof(int), i, in);
    printf("a=%d", a);

    return 0;
}
*/















#include <math.h>			//бібліотека математичних функцій
#include <stdio.h>


int main() {
    FILE* f; 			//файловий дескриптор
    int i,k,n=10;
    char s[]="String";
    float r;

    f=fopen("file_bin","wb");  //створюємо двійковий файл з назвою file_bin
    //	для запису даних (параметр “wb”)
    for(i=1;i<=n;i++){
        r=pow(i,1.0/3);		//розрахунок кубічного кореня з числа і
        fwrite(s,sizeof(s),1,f);    //запис слова "String" у файл
        fwrite(&i,sizeof(int),1,f); //запис цілого числа (номер рядка) у файл
        fwrite(&r,sizeof(float),1,f); //запис дійсного числа (корінь кубічний) у файл
        printf("\n%s %d %f",s,i,r); //контрольний вивід на екран
    }
    fclose(f); 				//закриття файлу
    printf("\n");
    f=fopen("file_bin","rb"); //відкриття двійковго файлу для читання
    for(i=n; i>0; i--) {    //переміщення покажчика файлу
        fseek(f,(i-1)*(sizeof(s)+sizeof(int)+sizeof(float)),SEEK_SET);
        fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
        fread(&n,sizeof(int),1,f);		//читати ціле число
        fread(&r,sizeof(float),1,f);	//читати дійсне число
        printf("\n%s %d %f",s,n,r);    	//вивести вміст файлу на екран
    }
    //getchar();	//затримка - очікування натиснення клавіші Enter
    printf("\nenter k:");
    scanf("%d",&k);
    n=10;
    if(k>n){
        printf("error.out of file.");
        return 1;
    }

    fseek(f,k*(sizeof(s)+sizeof(int)+sizeof(float)),SEEK_SET);
//    fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
//    fread(&n,sizeof(int),1,f);		//читати ціле число
//    fread(&r,sizeof(float),1,f);	//читати дійсне число
//    printf("\n%s %d %f\n",s,n,r);    	//вивести вміст файлу на екран


    for(i=k; i>1; i--) {    //переміщення покажчика файлу
        fseek(f,(-2)*(sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
        fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
        fread(&n,sizeof(int),1,f);		//читати ціле число
        fread(&r,sizeof(float),1,f);	//читати дійсне число
        printf("%s %d %f\n",s,n,r);    	//вивести вміст файлу на екран
    }
    printf("\nstep2\n");

    fseek(f,k*(sizeof(s)+sizeof(int)+sizeof(float)),SEEK_SET);
    fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
    fread(&n,sizeof(int),1,f);		//читати ціле число
    fread(&r,sizeof(float),1,f);	//читати дійсне число
    printf("%s %d %f\n",s,n,r);    	//вивести вміст файлу на екран


    n=10;
    printf("n=%d, k=%d\n", n, k);

//    for(i=0;i<=k;i++){
//        fseek(f, (2)*(sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
//        fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
//        fread(&n,sizeof(int),1,f);		//читати ціле число
//        fread(&r,sizeof(float),1,f);	//читати дійсне число
//        printf("\ni=%d %s %d %f",i,s,n,r);    	//вивести вміст файлу на екран
//    }

           fseek(f, (sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
           fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
           fread(&n,sizeof(int),1,f);		//читати ціле число
           fread(&r,sizeof(float),1,f);	//читати дійсне число
           printf("\ni=%d %s %d %f",i,s,n,r);    	//вивести вміст файлу на екран

           fseek(f, (sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
           fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
           fread(&n,sizeof(int),1,f);		//читати ціле число
           fread(&r,sizeof(float),1,f);	//читати дійсне число
           printf("\ni=%d %s %d %f",i,s,n,r);    	//вивести вміст файлу на екран

           fseek(f, (sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
           fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
           fread(&n,sizeof(int),1,f);		//читати ціле число
           fread(&r,sizeof(float),1,f);	//читати дійсне число
           printf("\ni=%d %s %d %f",i,s,n,r);    	//вивести вміст файлу на екран

           fseek(f, (sizeof(s)+sizeof(int)+sizeof(float)),SEEK_CUR);
           fread(&s,sizeof(s),1,f);	//читати з файлу слово "String"
           fread(&n,sizeof(int),1,f);		//читати ціле число
           fread(&r,sizeof(float),1,f);	//читати дійсне число
           printf("\ni=%d %s %d %f",i,s,n,r);    	//вивести вміст файлу на екран




           printf("\nstep3\n");
}




/* task 3.
Відкорегуйте наведений приклад наступним чином:
1) після заповнення файлу даними і його закриття - ввести з клавіатури ціле число k;
2) після відкриття файлу в режимі читання - перемістити покажчик файлу
 від початку на k позицій “рядок-номер-дійсне число”;
3) якщо переміщення відбулося неуспішно (вийшли за рамки файлу) -
повідомлення про помилку і вихід з програми;
4) в разі успішного переміщення - провести послідовне читання даних з файлу
 наступним чином:
    - спочатку - від поточної позиції, рухаючись у напрямку початку файлу;
    - після досягнення початку файлу - знову стартувати від  k-тої позиції
    і читати в напрямку кінця файлу;
    - функцію fseek() застосовувати тільки там, де це дійсно необхідно!
    - результат кожного читання виводити на екран.

Проаналізувати всі прочитані дані, переконатися, що їх прочитано в повному обсязі.
*/



/* task 4.
1) відкрити в режимі запису двійковий файл “contacts.dat”, до якого в циклі
програми внести наступні дані(хоча б 10-11 записів):
    прізвище та ім’я особи;
    вік особи (дійсне число у форматі Р.М, де Р - кількість років,
    М - кількість місяців);
    телефон (6-значне ціле число).
2) по закінченні запису - вивести весь перелік контактів на екран(з метою контролю);
3) організувати “дзеркальну” перестановку записів - перший поміняти з останнім,
другий - з передостаннім і т.д. Результати перестановки одразу записувати в той самий файл, звідки дані читалися;
Примітка: для проведення перестановки "допоміжний" файл НЕ СТВОРЮВАТИ!
4) по закінченні перестановки - прочитати результат з файлу, переконатись в коректності
проведених перестановок, а також що жоден запис не втрачено.
*/
